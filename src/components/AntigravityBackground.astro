---

---

<canvas
    id="antigravity-canvas"
    class="fixed top-0 left-0 w-full h-full -z-10 bg-slate-950"></canvas>

<script>
    const canvas = document.getElementById("antigravity-canvas");
    /** @type {CanvasRenderingContext2D} */
    const ctx = canvas.getContext("2d");

    let width, height;
    let particles = [];

    // Configuration
    const PARTICLE_COLOR = "rgba(255, 255, 255, 0.8)";
    const PARTICLE_RADIUS = 1.5;
    const GRID_SPACING = 35; // Grid density
    const MOUSE_RADIUS = 120; // Radius of influence
    const ELASTICITY = 0.08; // Return speed (higher = faster snap back)
    const FRICTION = 0.85; // Damping (lower = less slide)
    const MOUSE_STRENGTH = 3; // How hard the mouse pulls (factor)

    let mouse = { x: -1000, y: -1000 };

    class Particle {
        constructor(x, y) {
            this.originX = x;
            this.originY = y;
            this.x = x;
            this.y = y;
            this.vx = 0;
            this.vy = 0;
        }

        update() {
            // Distance from mouse
            const dx = mouse.x - this.x;
            const dy = mouse.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Force from mouse (attraction)
            let forceX = 0;
            let forceY = 0;

            if (distance < MOUSE_RADIUS) {
                // Calculate interaction
                const force = (MOUSE_RADIUS - distance) / MOUSE_RADIUS;
                const angle = Math.atan2(dy, dx);

                // Attraction: Move towards mouse
                forceX = Math.cos(angle) * force * MOUSE_STRENGTH;
                forceY = Math.sin(angle) * force * MOUSE_STRENGTH;
            }

            // Spring force back to origin
            const springDx = this.originX - this.x;
            const springDy = this.originY - this.y;

            // Apply forces
            this.vx += forceX + springDx * ELASTICITY;
            this.vy += forceY + springDy * ELASTICITY;

            // Apply friction
            this.vx *= FRICTION;
            this.vy *= FRICTION;

            // Update position
            this.x += this.vx;
            this.y += this.vy;
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, PARTICLE_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = PARTICLE_COLOR;
            ctx.fill();
        }
    }

    function init() {
        resize();
        animate();
    }

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        createParticles();
    }

    function createParticles() {
        particles = [];
        const rows = Math.ceil(height / GRID_SPACING);
        const cols = Math.ceil(width / GRID_SPACING);

        // Center the grid
        const startX = (width - cols * GRID_SPACING) / 2;
        const startY = (height - rows * GRID_SPACING) / 2;

        for (let r = 0; r <= rows; r++) {
            for (let c = 0; c <= cols; c++) {
                // Add random slight offset for organic feel
                const offsetX = (Math.random() - 0.5) * 5;
                const offsetY = (Math.random() - 0.5) * 5;
                const x = startX + c * GRID_SPACING + offsetX;
                const y = startY + r * GRID_SPACING + offsetY;
                particles.push(new Particle(x, y));
            }
        }
    }

    function animate() {
        ctx.clearRect(0, 0, width, height);

        particles.forEach((p) => {
            p.update();
            p.draw();
        });

        requestAnimationFrame(animate);
    }

    window.addEventListener("resize", resize);
    window.addEventListener("mousemove", (e) => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
    });

    window.addEventListener("mouseleave", () => {
        mouse.x = -1000;
        mouse.y = -1000;
    });

    init();
</script>
